/***
 * file: board.js
 * version: 0.6.0
 * author: https://github.com/quasto
  ***/

/*** import ***/
var	layouts = require('./utils/layout'),
	registers = require('./utils/register'),
	utils = require('./utils/utils'),
	path = require('path');
	_ = require('underscore'),
	fs = require('fs'),
	clone = require('clone'),
	Gpio = require('./lib/gpio').Gpio,
	Adc = require('./lib/adc').Adc,
	Pwm = require('./lib/pwm').Pwm;
	
var	logger,				//winston logger
	layout,
	register;

/***
register = { 
			"A0"	:	
			{
				"DEF"	: "A0",
				"TYP"	: "analog",
				"NUM"	: "139",
				"MAP"	: "A0",
				"PIN"	: [Object Adc]
				
			},...
			"D2"	:	
			{
				"DEF"	: "D2",
				"TYP"	: "digital",
				"NUM"	: "117",
				"MAP"	: "SDA",
				"MOD"	: "input","output",
				"PIN"	: [Object Gpio]
			},...
			"P11" :
			{
				"DEF"	: "P11",
				"TYP"	: "pwm",
				"NUM"	: "117",
				"MAP"	: "D11",
				"PIN"	: [Object Pwm]
			}
***/

	
/*** constants ***/	
var	CHECK_MSG = {	PIN_UNDEFINED : 	"The specified pin is undefined!",
					PIN_NOT_DIGITAL: 	"The specified pin [{0}] is not a Digital pin",
					PIN_NOT_ANALOG: 	"The specified pin [{0}] is not an Analog pin",
					PIN_NOT_VIRTUAL: 	"The specified pin [{0}] is not a Virtual pin",
					PIN_NOT_LAYOUT:		"The specified pin [{0}] is not defined in the board layout!",
					PIN_NOT_DEFINED:	"The specified pin [{0}] is not already defined! You must first, call pinMode!",
					MODE_NOT_VALID: 	"The specified mode [{0}] for pin [{1}] is not valid.",
					MODE_UNDEFINED : 	"The specified mode for pin [{0}] is undefined!"
				};
				
module.exports = Board;

/*** constructor ***/
function Board(options) {
	//load the default options from config file
	this.options = require('./config');
	//user can specifies overwrite options in the costructor
	utils.mergeRecursive(this.options, options);
	
	layout = layouts[this.options.layout];
	register = registers[this.options.layout];
	//setting the logger;
	logger = utils.getLogger(this.options.logger);
	logger.debug(this.options);
	
	/*** Board attributes ***/
	Board.prototype.pin = layout;
	Board.prototype.LOW = utils.LOW;
	Board.prototype.HIGH = utils.HIGH;
	Board.prototype.MODES = utils.MODES; 
	Board.prototype.logger = logger;
	
}

/*** PUBLIC ***/  
/*** Board functions ***/
Board.prototype.connect = function(callback){
	logger.info("Connecting to the Board "+ this.options.layout +"...");
	var that = this;
	
	//disabilito i pwm, perchè se restano abilitati dalla volta precedente, non possono più essere usati come pin digitali.
	var pin_pwm = _.filter(register, function(pin){ return pin.TYP == 'pwm'});
	_.each(pin_pwm,function(value, key, list){
		fs.writeFileSync('/sys/class/mcuio_pwm/'+value.MAP+'/enable', '0');
		fs.writeFileSync('/sys/class/mcuio_pwm/'+value.MAP+'/value', '0');
	});
	
	this.blink(75, 1500, 'D13');
	logger.info("Board Connection Success");
	callback();

}


Board.prototype.blink = function(){
	var that = this;
	// retrieve arguments as array
    var args = [];
    var delay, duration;
	for (var i = 0; i < arguments.length; i++) {
        args.push(arguments[i]);
    }
	var delay, led, duration;
	//check loglevel parameters
	if (args.length > 0) delay = args.shift(); else throw new Error("specify delay parameter.");
    if (args.length > 0) duration = args.shift(); else duration = 0;
	if (args.length > 0) led = args.shift(); else led = layout.digital.D13;

	if ( !isNaN(delay) ){
		if( typeof(duration) != 'undefined'  && !isNaN(duration) ){
			that.pinMode(led, utils.MODES.OUTPUT);
			var t = utils.LOW,
			interval = setInterval( function(){
				that.digitalWrite(led, t );
				t = t == utils.LOW ? utils.HIGH : utils.LOW;
			}, delay);
			
			if(duration > 0 ){
				setTimeout(function(){
					clearInterval(interval);
					that.digitalWrite(led, utils.LOW);
				},duration);
			}
		}
		else{
			throw new Error("duration is not a number."); 
		}
	}else{
		throw new Error("delay is not a number."); 
	}

	
}
Board.prototype.pinMode = function(pin, mode) {
	try {
		checkPinMode(pin, mode, function(err){
			if(err){
				throw err;
			}
			else{
				switch(mode.toLowerCase()) {
					case 'input':
						register[pin].PIN = new Gpio(register[pin].NUM, 
													register[pin].MAP,
													'in',
													'both');
						register[pin].MOD = mode;
						break;
					case 'output':
						register[pin].PIN = new Gpio(register[pin].NUM, 
													register[pin].MAP,
													'out');
						register[pin].MOD = mode;
						break;
					case 'pwm':
						register[pin].PIN = new Pwm(register[pin].NUM, 
													register[pin].MAP);
						register[pin].MOD = mode;
						break;
					case 'servo':
						//TODO
						break;
				}
			}
		});
	}
	catch(err){
		logger.error("BOARD PIN MODE ERROR - " + err.message);
		process.exit(1);
	}
}
Board.prototype.digitalWrite = function(pin, value) {
    try {
		process.nextTick(function(){
			checkDigitalWrite(pin, function(err){
				if(err){
					logger.error(err.message);
				}else{
					register[pin].PIN.writeSync(value);
				}
			});		
		});
	}
	catch(err){
		logger.error("BOARD DIGITAL WRITE ERROR - " + err.message);
	}
}
Board.prototype.digitalRead = function(pin, callback) {
	try {
		process.nextTick(function(){
			checkDigitalRead(pin,function(err){
				if(err){
					logger.error(err.message);
				}
				else{
					if (typeof callback === 'function')
						register[pin].PIN.watch(function(err, val){
							if(err) logger.error(err.message);
							else callback( { value : val } );
						});
					//TODO read sync
					//else {console.log(register[pin].PIN.readSync());
					//	return register[pin].PIN.readSync();
					//	}
				}
			});
		});
	}
	catch(err){
		logger.error("BOARD DIGITAL READ ERROR - " + err.message);
	}  
}
Board.prototype.analogWrite = function(pin, value) {
    try {
		process.nextTick(function(){
			checkAnalogWrite(pin, function(err){
				if(err){
					logger.error(err.message);
				}else{
					if(value>=255) value = 255;
					if(value<=0) value = 0;
					register[pin].PIN.writeSync(value);	
				}
			});
		});
	}
	catch(err){
		logger.error("BOARD ANALOG WRITE ERROR - " + err.message);
	}
}
Board.prototype.analogRead = function(pin, options, callback) {
    try {
		var opts = clone(this.options);
		
		if(typeof(options) == 'function' && typeof(callback) == 'undefined' ){
			callback = options;
			options = {}
		}
		utils.mergeRecursive(opts, options);
		
		process.nextTick(function(){
			checkAnalogRead(pin,function(err){
				if(err){
					logger.error(err.message);
				}
				else{
					if(typeof(register[pin].PIN) == 'undefined' || typeof(register[pin].PIN) == {} ){
						register[pin].PIN = new Adc(register[pin].NUM, 
													register[pin].MAP,
													opts);
					}
					register[pin].PIN.watch(function(err, val){
						if(err) logger.error(err.message);
						else callback( { value : val } );
					}); 
				}
			});
		});
	}
	catch(err){
		logger.error("BOARD ANALOG READ ERROR - " + err.message);
	}
}
Board.prototype.servoWrite = function(pin, angle){
    try {
		process.nextTick(function(){
			checkServoWrite(pin,function(err){
				if(err){
					logger.error(err.message);
				}
				else{
					var cmd = JSON.stringify({command:[{cmd: 'write', pin: pin, value: angle}]});
					//socket.write(cmd,'utf8'); //when connection is ok, emit the request
					pushWriteRequest(cmd);
				}
			});
		});
	}
	catch(err){
		logger.error("BOARD SERVO WRITE ERROR - " + err.message);
	}
}
/*** Virtual Board functions ***/ 
Board.prototype.virtualWrite = function(virtualpin, value){
	try {
		checkVirtualWrite(pin,function(err){
			if(err){
				logger.error(err.message);
			}
			else{
				var cmd = JSON.stringify({ command:[ {cmd: 'virtualwrite', pin: virtualpin, value: value } ]});
				pushWriteRequest(cmd);
			}
		});
				
	}
	catch(err){
		logger.error(err);
	}
}
Board.prototype.virtualRead = function(virtualpin, calback){
	try {
		checkVirtualRead(pin,function(err){
			if(err){
				logger.error(err.message);
			}
			else{
				var cmd = JSON.stringify({command:[{cmd: 'vread', pin: virtualpin}]});
				socket.write(cmd,ENCODING,readback(pin, callback)); //when connection is ok, emit the request
			}
		});
	}
	catch(err){
		logger.error(err.message);
	} 
}

/*** Check functions ***/
function checkPinMode(pinnumber, mode, callback){
	try{	
		if( typeof(pinnumber) == 'undefined'){
			callback( new Error(CHECK_MSG.PIN_UNDEFINED) );return false;
		}
		if( !pinnumber.toLowerCase().startsWith('d') && !pinnumber.toLowerCase().startsWith('p')){ 
			callback( new Error(String.format(CHECK_MSG.PIN_NOT_DIGITAL,pinnumber)) );return false
		}
		if( !utils.contains(layout.digital, pinnumber) && !utils.contains(layout.pwm, pinnumber)){
			callback( new Error(String.format(CHECK_MSG.PIN_NOT_LAYOUT,pinnumber)) );return false;
		}
		if( typeof(mode) == 'undefined'){
			callback(new Error(String.format(CHECK_MSG.MODE_UNDEFINED,pinnumber)) );return false;
		}
		if(	mode.toLowerCase() != utils.MODES.OUTPUT.toLowerCase()	&& 
			mode.toLowerCase() != utils.MODES.INPUT.toLowerCase() 	&&
			mode.toLowerCase() != utils.MODES.PWM.toLowerCase() 	&& 
			mode.toLowerCase() != utils.MODES.SERVO.toLowerCase()	){
			callback(new Error(String.format(CHECK_MSG.MODE_NOT_VALID, mode, pinnumber) + " Allowed modes are: "+ utils.MODES.OUTPUT +", "+ utils.MODES.INPUT + ", "+ utils.MODES.PWM + ", "+ utils.MODES.SERVO ));return false;
		}
		
		callback(null);
		return true;
	}
	catch(err){
		callback( new Error('Check Pin Mode: '+ err.message) );
		return false
	}
}
function checkDigitalWrite(pinnumber, callback){	
	try{
		if( typeof(pinnumber) == 'undefined'){
			callback( new Error( CHECK_MSG.PIN_UNDEFINED ) );return false;
		}
		if( !pinnumber.toLowerCase().startsWith('d')){ 
			callback( new Error( String.format(CHECK_MSG.PIN_NOT_DIGITAL, pinnumber) ) );return false;
		}
		if(typeof(register[pinnumber].MOD) == 'undefined'){
			callback( new Error( String.format(CHECK_MSG.PIN_NOT_DEFINED, pinnumber) ) );return false;
		}
		if( !utils.contains(layout.digital, pinnumber) ){
			callback( new Error(String.format(CHECK_MSG.PIN_NOT_LAYOUT, pinnumber) ) );return false;
		}
		if(register[pinnumber].MOD.toLowerCase() != utils.MODES.OUTPUT.toLowerCase() ){
			callback(new Error( String.format(CHECK_MSG.MODE_NOT_VALID, register[pinnumber].MOD.toLowerCase(), pinnumber) + " Allowed modes are: "+ utils.MODES.OUTPUT));return false;
		}
		
		callback(null);
		return true;
	}
	catch(err){
		callback( new Error('Check Digital Write: '+ err.message) );
		return false
	}
}
function checkDigitalRead(pinnumber, callback){
	try{
		if( typeof(pinnumber) == 'undefined'){
			callback( new Error( CHECK_MSG.PIN_UNDEFINED ) );return false;
		}
		if( !pinnumber.toLowerCase().startsWith('d')){ 
			callback( new Error( String.format(CHECK_MSG.PIN_NOT_DIGITAL, pinnumber) ) );return false;
		}
		if(typeof(register[pinnumber].MOD) == 'undefined'){
			callback( new Error( String.format(CHECK_MSG.PIN_NOT_DEFINED, pinnumber) ) );return false;
		}
		if( !utils.contains(layout.digital, pinnumber) ){
			callback( new Error(String.format(CHECK_MSG.PIN_NOT_LAYOUT, pinnumber) ) );return false;
		}
		if(	register[pinnumber].MOD.toLowerCase() != utils.MODES.OUTPUT.toLowerCase()	&& 
			register[pinnumber].MOD.toLowerCase() != utils.MODES.INPUT.toLowerCase() 	&&
			register[pinnumber].MOD.toLowerCase() != utils.MODES.PWM.toLowerCase() ){
			callback(new Error(String.format(CHECK_MSG.MODE_NOT_VALID, register[pinnumber].MOD.toLowerCase(), pinnumber) + " Allowed modes are: "+ utils.MODES.OUTPUT +", "+ utils.MODES.INPUT + ", "+ utils.MODES.PWM ));return false;
		}
		
		callback(null);
		return true;
	}
	catch(err){
		callback( new Error('Check Digital Read: '+ err.message) );
		return false
	}
}
function checkAnalogWrite(pinnumber,callback){	
	try{
		if( typeof(pinnumber) == 'undefined'){
			callback( new Error( CHECK_MSG.PIN_UNDEFINED ) );return false;
		}
		if( !pinnumber.toLowerCase().startsWith('d') && !pinnumber.toLowerCase().startsWith('p')){ 
			callback( new Error( String.format(CHECK_MSG.PIN_NOT_DIGITAL, pinnumber) ) );return false;
		}
		if(typeof(register[pinnumber].MOD) == 'undefined'){
			callback( new Error( String.format(CHECK_MSG.PIN_NOT_DEFINED, pinnumber) ) );return false;
		}
		if( !utils.contains(layout.pwm, pinnumber) ){
			callback( new Error(String.format(CHECK_MSG.PIN_NOT_LAYOUT, pinnumber) ) );return false;
		}
		if(register[pinnumber].MOD.toLowerCase() != utils.MODES.PWM.toLowerCase() ){
			callback(new Error( String.format(CHECK_MSG.MODE_NOT_VALID, register[pinnumber].MOD.toLowerCase(), pinnumber) + " Allowed modes are: "+ utils.MODES.PWM));return false;
		}
		
		callback(null);
		return true;
	}
	catch(err){
		callback( new Error('Check Analog Write: '+ err.message) );
		return false
	}
}
function checkAnalogRead(pinnumber,callback){
	try{
		if( typeof(pinnumber) == 'undefined'){
			callback( new Error( CHECK_MSG.PIN_UNDEFINED ) );return false;
		}
		if( !pinnumber.toLowerCase().startsWith('a') && !pinnumber.toLowerCase().startsWith('p')){ 
			callback( new Error( String.format( CHECK_MSG.PIN_NOT_ANALOG, pinnumber ) ) );return false;
		}
		/* analog pin are in input mode (default), non verifico il pin mode
		if(typeof(register[pin].MOD) == 'undefined'){
			callback( new Error( String.format(CHECK_MSG.PIN_NOT_DEFINED, pinnumber) ) );return false;
		}
		*/
		if( !utils.contains(layout.analog, pinnumber) && !utils.contains(layout.pwm, pinnumber)){
			callback( new Error(String.format(CHECK_MSG.PIN_NOT_LAYOUT, pinnumber) ) );return false;
		}
		callback(null);
		return true;
	}
	catch(err){
		callback( new Error('Check Analog Read: '+ err.message) );
		return false
	}
}
function checkServoWrite(pinnumber,callback){	
	try{
		if( typeof(pinnumber) == 'undefined'){
			callback( new Error( CHECK_MSG.PIN_UNDEFINED ) );return false;
		}
		if( !pinnumber.toLowerCase().startsWith('d')){ 
			callback( new Error( String.format( CHECK_MSG.PIN_NOT_DIGITAL, pinnumber ) ) );return false;
		}
		if(typeof(register[pinnumber].MOD) == 'undefined'){
			callback( new Error( String.format(CHECK_MSG.PIN_NOT_DEFINED, pinnumber) ) );return false;
		}
		if( !utils.contains(layout.servo, pinnumber) ){
			callback( new Error(String.format(CHECK_MSG.PIN_NOT_LAYOUT, pinnumber) ) );return false;
		}
		if(register[pinnumber].MOD.toLowerCase() != utils.MODES.SERVO.toLowerCase() ){
			callback(new Error( String.format(CHECK_MSG.MODE_NOT_VALID, register[pinnumber].MOD.toLowerCase(), pinnumber) + " Allowed modes are: "+ utils.MODES.SERVO));return false;
		}
		
		callback(null);
		return true;
	}
	catch(err){
		callback( new Error('Check Servo Write: '+ err.message) );
		return false
	}
}
function checkVirtualWrite(pinnumber, callback){	
	try{
		if( typeof(pinnumber) == 'undefined'){
			callback( new Error( CHECK_MSG.PIN_UNDEFINED ) );return false;
		}
		if( !pinnumber.toLowerCase().startsWith('v')){ 
			callback( new Error( String.format( CHECK_MSG.PIN_NOT_VIRTUAL, pinnumber ) ) );return false;
		}
		callback(null);
		return true;
	}
	catch(err){
		callback( new Error('Check Virtual Write: '+ err.message) );
		return false
	}
}
function checkVirtualRead(pinnumber){	
	try{
		if( typeof(pinnumber) == 'undefined'){
			callback( new Error( CHECK_MSG.PIN_UNDEFINED ) );return false;
		}
		if( !pinnumber.toLowerCase().startsWith('v')){ 
			callback( new Error( String.format( CHECK_MSG.PIN_NOT_VIRTUAL, pinnumber ) ) );return false;
		}
		callback(null);
		return true;
	}
	catch(err){
		callback( new Error('Check Virtual Read: '+ err.message) );
		return false
	}
}
