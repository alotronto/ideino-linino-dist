#!/usr/bin/env python
# -*- coding: utf-8 -*-

# file: bridge-firmata.py
# author: https://github.com/andrea-83

import json, pyfirmata, thread, time, socket, logging, logging.handlers ,argparse, os
from pyfirmata import Arduino, util


dirname, filename = os.path.split(os.path.abspath(__file__))

#=====Arduino======================================
arduino_serial = 'SPI0'                 
arduino_serial_port = '/dev/tty'+arduino_serial
arduino_serial_brate = 57600

#====variabile e strutture dati====================
logger_file=dirname+'/bridge-firmata.log'
layout_path='/opt/ideino-linino/node_modules/ideino-linino-lib/utils/layout.json'
host=''
sock=[None]                                                         #socket object
port= 9810                                                          #1557
resolution=15                                                       #read resolution param, DISABLE-> set resolution=0
hash_getpin={}                                                      #get_pin registry
hash_tx={}                                                          #read value registry
read_pin=[]                                                         #request read pin


def arduino():
    arduino = Arduino(arduino_serial_port,baudrate=arduino_serial_brate)
    iterator = util.Iterator(arduino)
    iterator.start()
    return arduino
    
def excute_command (command):

    cmd = json.loads(command)
        
    for i in range(len(cmd['command'])):                                        #read python object param

        cmd_type=cmd['command'][i]['cmd'].upper()
        pin=cmd['command'][i]['pin']
        cmd_ad=pin[0]                                                           #pin type
        cmd_pin=pin[1:3]                                                        #pin
        cmd_io=''
        cmd_value=''
        cmd_firm=''
        if (cmd_ad=='A' and (pin not in (layout[board]['analog']))):            
            logger.warning('Pin '+cmd_pin+' is not an analog pin')
            break
        elif (cmd_ad=='D' and (pin not in (layout[board]['digital']))):         
            logger.warning('Pin '+cmd_pin+' is not an digital pin')
            break

   #MODE: INPUT,OUTPUT, PWM, SERVO

        if(cmd_type == 'MODE'):                                                 #il comando lanciato è di tipo MODE
            cmd_io = cmd['command'][i]['mode'][0]                               #cmd_io puo essere input o output (i=input, o=output)
            cmd_firm = cmd_ad.lower()+':'+cmd_pin+':'+cmd_io                    #firmata command (ex: 'd:13:o')
            if(cmd_ad=='A' and cmd_io!='i'):
                logger.warning('Analog pin '+cmd_pin+' can only operate in input mode')
            elif(cmd_ad=='D'):
                if pin not in hash_getpin: 
                    arduino.digital[int(cmd_pin)].write(0)                      #reset pin a 0 (non funziona con pull-up)
                    pin_d = arduino.get_pin(cmd_firm)		        
                    hash_getpin.update({pin:pin_d})
                if(cmd_io == 'i'):
                    if (hash_getpin[pin].mode != 0):            #se il pin è gia in modalità input non faccio il reset del pin (0 INPUT - 1 OUTPUT - 2 ANALOG - 3 PWM - 4 SERVO)
                        hash_getpin[pin].write(0)                              #reset pin a 0 (non funziona con pull-up)
                        hash_getpin[pin].mode=pyfirmata.INPUT
                        
                if(cmd_io == 'o'):
                    hash_getpin[pin].mode=pyfirmata.OUTPUT
                    hash_getpin[pin].write(0)                   #reset pin a 0 

                if(cmd_io == 'p'):
                    hash_getpin[pin].mode=pyfirmata.PWM

                if(cmd_io == 's'):
                    hash_getpin[pin].mode=pyfirmata.SERVO
                
            #logger.debug("Command >>> Type: " + cmd_type + "; Pin:" + cmd_pin + "; A/D:" + cmd_ad.lower() + "; I/O:" + cmd_io + "; Firmata:" + cmd_firm)


            #Write COMMAND

        if( cmd_type=='WRITE'): 

            cmd_value = cmd['command'][i]['value']

            try:
                if (cmd_ad == 'A'):
                    logger.warning("Write on analog pin "+cmd_pin+" is impossible: Arduino don't support analog write")
                elif (cmd_ad == 'D'):
                    arduino.digital[int(cmd_pin)].write(float(cmd_value))

                    #logger.debug("Command >>> Type: "+cmd_type+"; Pin:"+cmd_pin+"; A/D:"+cmd_ad.lower()+"; Write Value:"+str(cmd_value))

            except:
                logger.error('Write on digital pin '+cmd_pin+' is impossible: pin is in input mode')

                    
            #Read COMMAND  

        elif( cmd_type=='READ'): 
                                                                            #pin with read request            
            try:
                if cmd_ad == 'D':
                    if pin not in read_pin:                       
                        read_pin.append((pin))
                        
                elif cmd_ad == 'A': 
                    arduino.analog[int(cmd_pin)].enable_reporting()
                    if pin not in read_pin:
                        read_pin.append((pin))
                
                #logger.debug("Command >>> Type: "+cmd_type+"; Pin:"+cmd_pin+"; A/D:"+cmd_ad.lower())

            except:
                logger.error('read command error')


def polling(thread, delay):

    while True:
    
        time.sleep(delay)
        hash_tmp={}   

        #========DIGITAL PIN===========
        
        for pin_d in layout[board]['digital']:                                              # i pin 0 1 sono riservati alla seriale
            if pin_d in read_pin:
                if pin_d not in hash_tx:
                        hash_tx.update({pin_d:0})                                        # bisogna verificare che il pin sia in input?                                                                    
                if arduino.digital[int(pin_d[1:3])].read(): 
                    hash_tmp.update({pin_d:1})                                              # invio 1 e 0 al posto di True e False
                else:                                                                       #(arduino.digital[i].read()== None) or (arduino.digital[i].read()== False):
                    hash_tmp.update({pin_d:0})

        #========ANALOG PIN=============    
        
        for pin_a in layout[board]['analog']:
            if pin_a in read_pin:
                if pin_a not in hash_tx:
                    hash_tx.update({pin_a:0})                                             #faccio la lettura solo se è stata effettuata la richiesta
                value=arduino.analog[int(pin_a[1:3])].read()
                if value is not None:                
                    value = int(value * 1023)
                    if hash_tx[pin_a]+resolution < value or hash_tx[pin_a]-resolution > value:            #to disable RESOLUTION set resolution variable to zero
                        hash_tmp.update({pin_a:value})                               
                else:
                    hash_tmp.update({pin_a:0})                                          #inizializzo la lettura del pin a zero


        for i in hash_tmp.keys():                                   
            if cmp(hash_tx[i],hash_tmp[i]):
                hash_tx[i]=hash_tmp[i]
                if sock[0] is not None:
                    sock[0].sendall('{"cmd": "read-back", "pin": "'+i.upper()+'", "value":'+str(hash_tx[i])+'}')
                #time.sleep(0.025)

def connection(s):
    while 1:
        conn, addr = s.accept()
        sock[0]=conn
        logger.info('Client connected:'+str(addr))
        handle(conn,addr)
        

def handle(conn, addr):       #handle websocket

    while 1:
        try:
            data = conn.recv(1024)
        except socket.error , msg:
            logger.error('data receive failed. Error code: '+str(msg[0])+' Error message: ' + msg[1])
            break
        if not data:
            break
            logger.debug('data received: '+data)
        try:                    
            if '}{' in data:                        #split the command received
                data=data.replace('}{','}-{')
                data=data.split('-')
                for i in data:
                    excute_command(i)
            else:
                excute_command(data)
        except :
            logger.error('json parse error on this command: '+str(data))
    
    logger.info('Client closed:'+str(addr))
    sock[0]=None
    conn.close()

def arg_par():
    
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter, description='bridge-firmata for ideino-linino options')
    parser.add_argument('-log', type=str, help='set log level [info, error, warn, debug] and handler[file, console, all] (default:%(default)s)',
                        metavar=('[handler]','[level]'), nargs=2 , default=['error','file'])
    parser.add_argument('-layout', type=str, help='set board layout [arduino_yun, linino_one] and layout file path(default:%(default)s)',
                        nargs=2 ,metavar=('[board]', '[file]'),default=['arduino_yun',layout_path])
						
    parser.add_argument('-resolution',type=int, help='set the analog resolution. (default:%(default)d)',nargs=1, metavar=('[resolution]'),default=[15])
    parser.add_argument('-serial',type=str, help='set the serial port [ATH0, SPI0] and baudrate. (default:%(default)s)',nargs=2, metavar=('[port]','[baudrate]'),default=['SPI0',57600])					

    args = parser.parse_args()
    return args
    
if __name__ == "__main__":


    args= arg_par()
    
    logger = logging.getLogger('bridge-firmata')
    formatter = logging.Formatter('%(asctime)s %(levelname)s: %(message)s')
    hdlr_file = logging.handlers.RotatingFileHandler(logger_file, maxBytes=3000, backupCount=3)   #logger file (backupCount= log file number, maxBytes=log file size)
    hdlr_console= logging.StreamHandler()
    hdlr_file.setFormatter(formatter)
    hdlr_console.setFormatter(formatter)

    log=args.log
    
    if log[0] == 'warn':                   
        level=logging.WARNING
    elif log[0] == 'error':
        level=logging.ERROR
    elif log[0] == 'debug':
        level=logging.DEBUG
    elif log[0] == 'info':
        level=logging.INFO

    if log[1] == 'file':
        logger.addHandler(hdlr_file)
    elif log[1] == 'all':
        logger.addHandler(hdlr_file)
        logger.addHandler(hdlr_console)
    elif log[1] == 'console':
        logger.addHandler(hdlr_console)

    board= args.layout[0]
    layout_path= args.layout[1]

    layout_file=open(layout_path)               #upload board layout
    file_data=layout_file.read()
    layout_file.close()
    layout=json.loads(file_data)


    logger.setLevel(level)              #WARNING,INFO,ERROR,DEBUG
    
    s = socket.socket()
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)  

    resolution = args.resolution[0]
    arduino_serial = args.serial[0]
    arduino_serial_port = '/dev/tty'+arduino_serial
    arduino_serial_brate = args.serial[1]
    
    arduino=arduino()
    
    try:
        s.bind((host, port))
    except socket.error , msg:
        logger.error('Bind failed. Error code: '+str(msg[0])+' Error message: ' + msg[1])
    s.listen(5)

    try:
        thread.start_new_thread( polling, ("Thread-1", 0.01))
        logger.debug('Polling thread started')
    except:
        logger.error('unable to start polling thread')

    connection(s)
        
    
    


